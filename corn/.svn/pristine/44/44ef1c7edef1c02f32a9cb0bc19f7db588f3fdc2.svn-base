#include "corn/enum.h"
#include <string.h>
#include <stdlib.h>
#ifndef compareHPP
#  include "corn/math/compare.hpp"
#endif
#ifndef strconvHPP
#   include "corn/string/strconv.hpp"
#endif
// in UNIX, MSC and BC++ strtoul is in stdlib.h
// it might be in other header files for other compiler vendors
//namespace CORN {
//______________________________________________________________________________
Enum_abstract::Enum_abstract()
: simple_label_table(0)
, descriptive_label_table(0)
{}
// This constructor is for enumeration that are simply integer numbers
//_2005-09-29___________________________________________________________________
Enum_abstract::Enum_abstract(const char **_label_table)
: simple_label_table(_label_table)
, descriptive_label_table(0)
{}
//_2005-09-29___________________________________________________________________
Enum_abstract::Enum_abstract(Label_description *_descriptive_label_table )
: simple_label_table(0)
, descriptive_label_table(_descriptive_label_table)
{}
//_2005-09-29___________________________________________________________________
bool Enum_abstract::is_label(const char *label)                      affirmation_
{  if (simple_label_table)
      for (int32 i = 0; simple_label_table[i] && strlen(simple_label_table[i]); i++)
        if (strcmp(label,simple_label_table[i]) == 0)
          return true;
   if (descriptive_label_table)
      for (int32 i = 0; descriptive_label_table[i].label != 0 && strlen(descriptive_label_table[i].label); i++)
        if (strcmp(label,descriptive_label_table[i].label) == 0)
          return true;
   return false;
}
//_2002-04-19_________________________________________________________is_label_/
int32 Enum_abstract::set_label(const char *label)
{  int32 new_value = 0;
   if (simple_label_table)
   {  for (int32 i = 0; simple_label_table[i] && strlen(simple_label_table[i]); i++)
         if (strcmp(label,simple_label_table[i]) == 0)
          new_value = i;
      // If the label wasn't found in the table, try case insensitive search.
      if (!new_value)
         for (int32 i = 0; simple_label_table[i] && strlen(simple_label_table[i]); i++)
            if (stricmp(label,simple_label_table[i]) == 0)
               new_value = i;
   } else if (descriptive_label_table)
   {  for (int32 i = 0; descriptive_label_table[i].label && strlen(descriptive_label_table[i].label); i++)
         if (strcmp(label,descriptive_label_table[i].label) == 0)
          new_value = i;
      // If the label wasn't found in the table, try case insensitive search.
      if (!new_value)
         for (int32 i = 0; descriptive_label_table[i].label && strlen(descriptive_label_table[i].label); i++)
            if (stricmp(label,descriptive_label_table[i].label) == 0)
               new_value = i;
   } else // simple integer enumeration (I.e. soil layers
        new_value = atoi(label);
   set_int32(new_value);
   return new_value;
}
//_2002-03-21 __________________________________________________________________
/*190109
const char *Labeled_enum::get_label(std::string &return_buffer)            const
{  int32 label_index = get_int32();
   if (simple_label_table)             return_buffer.append(simple_label_table[label_index]);
   else if (descriptive_label_table)   return_buffer.append(descriptive_label_table[label_index].label);
   else CORN::append_nat32_to_string(label_index);
   return return_buffer.c_str();
}
//_get_label____________________________________________2005-09-29__2002-04-01_/
*/
const char *Enum_abstract::append_label(std::string &return_buffer)            const
{  int32 label_index = get_int32();
   if (simple_label_table)             return_buffer.append(simple_label_table[label_index]);
   else if (descriptive_label_table)   return_buffer.append(descriptive_label_table[label_index].label);
   else CORN::append_nat32_to_string(label_index,return_buffer);
   return return_buffer.c_str();
}
//_append_label_____________________________________________________2019-01-09_/
std::ostream &Enum_abstract::stream_label(std::ostream &stream)       stream_IO_
{  int32 label_index = get_int32();
   #ifdef __BCPLUSPLUS__
   if (simple_label_table)             stream << simple_label_table[label_index];
   else if (descriptive_label_table)   stream << descriptive_label_table[label_index].label;
   else stream << label_index;
   #endif

   // WARNING Qt is not compiling this

   return stream;
}
//_stream_label_____________________________________________________2019-01-15_/



/*190108
static const char *num_str[]
={ "0","1","2","3","4","5","6","7","8","9"
, "10","11","12","13","14","15","16","17","18","19"
, "20","21","22","23","24","25","26","27","28","29"
, "30","31","32","33","34","35","36","37","38","39"
, "40","41","42","43","44","45","46","47","48","49"
, "50","51","52","53","54","55","56","57","58","59"
, "60","61","62","63","64","65","66","67","68","69"};
//______________________________________________________________________________
const char *Labeled_enum::get_label()                                      const
{  int32 label_index = get_int32();
   const char *result =
     (simple_label_table)        ? simple_label_table[label_index]
   : (descriptive_label_table)   ? descriptive_label_table[label_index].label
   :                               num_str[label_index];
   return result;
}
//_2005-09-29__2002-04-01____________________________________________get_label_/
*/
/*190109
const char *Labeled_enum::get_description(std::string &return_buffer)      const //190106
{  const char *result =
   descriptive_label_table
   ? descriptive_label_table[get_int32()].description
   : get_label();  // For simple label tables, simply return the label as the description.
   return_buffer.assign(result);                                                 //190106
   return return_buffer.c_str();                                                 //190106
   //190106   return result;
}
//_2005-09-29__________________________________________________get_description_/
*/
const char *Enum_abstract::append_description(std::string &return_buffer)      const //190106
{  if (descriptive_label_table)
        return_buffer.append(descriptive_label_table[get_int32()].description);
   else append_label(return_buffer);
   return return_buffer.c_str();                                                 //190106
}
//_append_description__________________________________2019-01-09__2005-09-29_/
nat16 Enum_abstract::get_max_label_length()             const
{  nat16 max_label_len  = 1; // Must be at least 1 character
   // Returns the longest label length.
   // This is used to determine the field size for Data_records enumeration attributes.
   if (simple_label_table)
       for (nat16 i = 0; simple_label_table[i] && strlen(simple_label_table[i]); i++)
           max_label_len = std::max<nat16>(max_label_len,(nat16)strlen(simple_label_table[i]));
   else if (descriptive_label_table)
       for (nat16 i = 0; descriptive_label_table[i].label && strlen(descriptive_label_table[i].label); i++)
           max_label_len = std::max<nat16>(max_label_len,(int)strlen(descriptive_label_table[i].label));
   else max_label_len  = 6;   // For enumerated label tabels
   return max_label_len;
}
//_2005-09-29_____________________________________________get_max_label_length_/
//} // namespace CORN
