#include "corn/container/bilist.h"
#include "corn/tabular/tabular_format.h"
namespace CORN {
///////////////////////////////////////////////////////////////////////////////
#define LABEL_format                "format"
#define LABEL_header_terminator     "header_terminator"
#define LABEL_column_headers        "column_headers"
#define LABEL_rows                  "rows"
#define LABEL_units_rows            "units_rows"
#define LABEL_units_start_row       "units_start_row"
#define LABEL_detail_lines          "detail_lines"
#define LABEL_header_field          "header_field"
#define LABEL_column                "column"
//______________________________________________________________________________
const char *variable_order_label_table[] =
{  "fixed"
,  "variable"
,0 };
//______________________________________________________________________________
#define     LABEL_data "data"

// This constructor is used when creating a new format using an editor
Common_tabular_file_format::Common_tabular_file_format
(Format_file_type format_file_type_)
:Common_parameters_data_record (NO_ASSOCIATED_DIRECTORY,"format")                //040925
,Extent_layout() // Delineation_layout()
,format_file_type_clad(format_file_type_)
,big_endian(false) // assume Intel processors
,carriage_return_line_feed(false)
,paginated(false)                                                                //070925
,FORTRAN_carriage_control(false)                                                 //020525
,defined_by("")                                                                  //990307
,defined_date() // default today                                                 //990307
,header_terminator(0)                                                            //990507
,column_headers_every_page(false)                                                //070925
,column_headers_delineation()
,detail_lines_delineation()                                                      //050411
,columns_1based()                                                                //040925
,variable_order_clad(fixed_order)                                                //020505
,missing_data_marker("")                                                         //090305
,year_offset_for_dates_with_only_two_digits_X(0)                                 //120331
,cgi_form_server("")                                                             //090305
,cgi_form_action("")                                                             //090305
,cgi_form_method("")                                                             //090305
{ }
//______________________________________________________________________________
// This constructor is used when loading a format
Common_tabular_file_format::Common_tabular_file_format
(const std::string &/*unused i_description*/
,Format_file_type   format_file_type_)
:Common_parameters_data_record(NO_ASSOCIATED_DIRECTORY,"format")                 //040925
,Extent_layout() // Delineation_layout()
,format_file_type_clad(format_file_type_)
,big_endian(false) // assume Intel processors
,carriage_return_line_feed(false)
,paginated(false)                                                                //070925
,FORTRAN_carriage_control(false)                                                 //020525
,defined_by("")                                                                  //990307
,defined_date() // default today                                                 //990307
,header_terminator(0)                                                            //990507
,column_headers_every_page(false)                                                //070925
,column_headers_delineation()
,detail_lines_delineation()                                                      //050411
,columns_1based()                                                                //040925
,variable_order_clad(fixed_order)                                                //020505
,missing_data_marker("")                                                         //090305
,year_offset_for_dates_with_only_two_digits_X(0)                                 //120331
,cgi_form_server("")                                                             //090305
,cgi_form_action("")                                                             //090305
,cgi_form_method("")                                                             //090305
{}
//______________________________________________________________________________
// This constructor is used by UED_export file
Common_tabular_file_format::Common_tabular_file_format()
:Common_parameters_data_record(NO_ASSOCIATED_DIRECTORY,"format")                 //040925
,Extent_layout() // Delineation_layout()
,format_file_type_clad(FILE_TYPE_unknown)
,big_endian(false) // assume Intel processors
,carriage_return_line_feed(false)
,paginated(false)                                                                //070925
,FORTRAN_carriage_control(false)                                                 //020525
,defined_by("")                                                                  //990307
,defined_date() // default today                                                 //990307
,header_terminator(0)                                                            //990507
,column_headers_every_page(false)                                                //070925
,column_headers_delineation()
,detail_lines_delineation()                                                      //050411
,columns_1based()                                                                //040925
,variable_order_clad(fixed_order)                                                //020505
,missing_data_marker("")                                                         //090305
,year_offset_for_dates_with_only_two_digits_X(0)                                 //120331
,cgi_form_server("")                                                             //090305
,cgi_form_action("")                                                             //090305
,cgi_form_method("")                                                             //090305
{}
//______________________________________________________________________________
const char *format_file_type_label_table[] =
{"unknown"
,"text"
,"binary"
,"dBase"
,"Lotus123"
,"Excel"
,0};
//______________________________________________________________________________
#define LABEL_description      "description"
#define LABEL_time_step        "time_step"
#define LABEL_format_file_type "format_file_type"
#define LABEL_big_endian       "big_endian"
#define LABEL_carriage_return_line_feed        "carriage_return_line_feed"
#define LABEL_FORTRAN_carriage_control "FORTRAN_carriage_control"
#define LABEL_defined_by       "defined_by"
#define LABEL_defined_date     "defined_date"
#define LABEL_notes            "notes"
#define LABEL_time_step_units "time_step_units"
// These are 1 based indexes  (because column references (in identification need to be 1 based)
DECLARE_CONTAINER_ENUMERATED_SECTION(Common_tabular_file_format::Column,Column_section_VV,1);
//______________________________________________________________________________
bool Common_tabular_file_format::expect_structure(bool for_write )
{  bool expected = Common_parameters_data_record::expect_structure(for_write );  //161023_120314
   structure_defined = false;                                                    //120314
   set_current_section(LABEL_format);
      setup_structure(*this,for_write);                                          //050411
      //Item::setup_structure(*this,for_write);                                  //180326
      //Extent_layout::setup_structure(*this,for_write);                         //180326
      expect_string(LABEL_description
         ,description.brief
         ,ARBITRARY_STRING_LENGTH_512);
      expect_enum(LABEL_format_file_type,format_file_type_clad);                 //020505
      expect_bool(LABEL_big_endian,big_endian,VV_bool_entry::form_true);
      expect_bool(LABEL_carriage_return_line_feed,carriage_return_line_feed,VV_bool_entry::form_true);
      expect_bool("paginated",paginated);                                        //070925
      expect_bool(LABEL_FORTRAN_carriage_control,FORTRAN_carriage_control,VV_bool_entry::form_true); //020525
      expect_string(LABEL_defined_by,defined_by,ARBITRARY_STRING_LENGTH_512);
      expect_int32(LABEL_defined_date,defined_date.date_num);
      //170525 expect_date(LABEL_defined_date,defined_date,false);
      expect_enum("column_order",variable_order_clad);                           //060324
      expect_int16(LABEL_header_terminator,header_terminator);                   //040925
      expect_int16("year_offset_when_only_two_digits",year_offset_for_dates_with_only_two_digits_X); //120331
   set_current_section("data_markers");                                          //050516
      expect_string("missing",missing_data_marker,ARBITRARY_STRING_LENGTH_256);  //050516
   set_current_section(LABEL_column_headers);
      column_headers_delineation.setup_structure(*this,for_write);               //040925
      expect_bool("column_headers_every_page",column_headers_every_page);        //070925
      expect_int16(LABEL_rows             ,column_headers_delineation.rows);
      expect_int16("units_row_offset"     ,column_headers_delineation.units_row_offset);
      expect_int16(LABEL_units_rows       ,column_headers_delineation.units_rows);
      expect_bool("units_parenthesis"     ,column_headers_delineation.units_parenthesis); //060324
      expect_string("1",column_header_static/*[1]*/,1024); //  column_header_static, 1024, 1 , 9 ,false);         //100104
   set_current_section(LABEL_detail_lines);
      expect_int16(LABEL_time_step,detail_lines_delineation.time_step);          //060223
      expect_enum(LABEL_time_step_units,detail_lines_delineation.time_step_units_enum); //060626
      detail_lines_delineation.setup_structure(*this,for_write);                 //050411
   set_current_section(LABEL_format);
   // column section is done from ET_tabular_format::Column   EXPECT_ENUMERATED_SECTION(LABEL_column,Column_section_VV,columns_1based);
   /*131209  I dont remember what the sample was for (perhaps debuggin)g
   set_current_section("sample");                                                //060621
      expect_file_name("excel",sample_excel_filename);                            //060621
   */
   structure_defined = true;                                                     //120314
   return expected;
}
//______________________________________________________________________________
/*181001 obsolete
bool Common_tabular_file_format::set_start()
{
   // we need to tell the header_fields what format
   // so we don't write unecessary fields for the format
#ifdef CHECK_NEEDED
100117 Don't remember what I was doing with this.
It may be obsolete because I now using parameter properties to get the units codes and caption
   FOR_EACH_IN(column,Common_tabular_file_format::Column,columns_1based,each_column)
   {  // set the column units_code translated from units_code  if "" and vica versa
      if (column->units_description=="")
         column->units_description = column->smart_units_code_enum.get_label();
      if (column->smart_units_code_enum.get_int32() == 0)
          column->smart_units_code_enum.set_label(column->units_description.c_str());
      //                Don't need to worry about UED_import_to_smart_units_code
   } FOR_EACH_END(each_column)
#endif
   return Common_parameters_data_record::set_start();                                   //051028
}
*/
//_set_start________________________________________________________2005-04-05_/
bool Common_tabular_file_format::Column::setup_structure(CORN::Data_record &data_rec,bool for_write) modification_
{  bool satup = Tabular_column::setup_structure(data_rec,for_write);
   if (!for_write)
   {  //10017  For backward compatibility, eventually delete  (there should not be a lot of files with this entry and units didn't match except for dates).
         data_rec.expect_enum("units_code",   units); // I used to store the numeric units code in hex
         data_rec.expect_string("description",caption ,255); // Description is being replaced by Caption //060626_
   }
   return satup;
}
//_setup_structure__________________________________________________2004-09-26_/
bool Common_tabular_file_format::Column::is_key_string
(const std::string &key)                                            affirmation_  //180820
{ return CORN::Tabular_column::is_key_string(key); }

/*180820  was probably only used for find_cstr now using is_key
const char *Common_tabular_file_format::Column::get_key()                  const
{  return CORN::Tabular_column::get_key();                                       //100116
}
*/
//_is_key_string____________________________________________________2003-09-26_/
void Common_tabular_file_format::reset_for_file_type()
{  // In the user interface, when the file type is change
   // we can set up some options that we know are not relevent for the file type.
   switch (format_file_type_clad.get())
   {  case FILE_TYPE_binary :
         column_headers_delineation.text_quote_mode_clad.set(Delineation_layout::NO_QUOTE);
         column_headers_delineation.delimit_mode_clad.set(Delineation_layout::DELIMIT_intrinsic);
         detail_lines_delineation. text_quote_mode_clad.set(Delineation_layout::NO_QUOTE);
         detail_lines_delineation.delimit_mode_clad.set(Delineation_layout::DELIMIT_intrinsic);
      break;
      case FILE_TYPE_dBase :
         column_headers_delineation.text_quote_mode_clad.set(Delineation_layout::NO_QUOTE);
         column_headers_delineation.delimit_mode_clad.set(Delineation_layout::DELIMIT_intrinsic);
         detail_lines_delineation. text_quote_mode_clad.set(Delineation_layout::NO_QUOTE);
         detail_lines_delineation.delimit_mode_clad.set(Delineation_layout::DELIMIT_intrinsic);
      break;
      case FILE_TYPE_lotus123 : // same as excel
      case FILE_TYPE_Excel :
         column_headers_delineation.text_quote_mode_clad.set(Delineation_layout::NO_QUOTE);
         column_headers_delineation.delimit_mode_clad.set(Delineation_layout::DELIMIT_intrinsic);
         detail_lines_delineation. text_quote_mode_clad.set(Delineation_layout::NO_QUOTE);
         detail_lines_delineation.delimit_mode_clad.set(Delineation_layout::DELIMIT_intrinsic);
      break;
      case FILE_TYPE_text :
      case FILE_TYPE_unknown :                                                   //091130
           //Should need to change anything for text user can define all
      break;
   }
}
//_reset_for_file_type______________________________________________2006-06-26_/
bool Common_tabular_file_format::default_R_text()                  modification_
{
   // Sets up format and delimit for R import/export text files.
   start_row_number=1;
   format_file_type_clad.set(FILE_TYPE_text);
   carriage_return_line_feed  = false;
   paginated                  = false;
   FORTRAN_carriage_control   = false;
   column_headers_every_page  = false;
   variable_order_clad.set(variable_order);
   missing_data_marker        = "";  // R can also be told to recognise  "NA" and "." and "na"
   bool col_delineation_set =
       column_headers_delineation.default_R_text()
    && detail_lines_delineation  .default_R_text();

   column_headers_delineation.start_row_number = 1;
   detail_lines_delineation.start_row_number = 2;
   return col_delineation_set;
}
//_2014-10-08___________________________________________________________________
bool Common_tabular_file_format::copy_from(const Common_tabular_file_format& source) //141008
{
   start_row_number          = source.start_row_number;
   format_file_type_clad.set(source.format_file_type_clad.get());
   carriage_return_line_feed  = source.carriage_return_line_feed;
   paginated                  = source.paginated;
   FORTRAN_carriage_control   = source.FORTRAN_carriage_control;
   column_headers_every_page  = source.column_headers_every_page;
   variable_order_clad.set(source.variable_order_clad.get());
   missing_data_marker        = source.missing_data_marker;  // R can also be told to recognise  "NA" and "." and "na"
   return
      // NYIExtent_layout::copy_from(source)   &&
       column_headers_delineation.copy_from(source.column_headers_delineation)
    && detail_lines_delineation  .copy_from(source.detail_lines_delineation);
}
//_copy_from________________________________________________________2014-10-08_/
nat16 Common_tabular_file_format::get_width_column(nat16 column_index)     const
{
   Column *col = dynamic_cast<Column *>
      (columns_1based.get_at(column_index));
   return col ? col->field_width : 0;
}
//_get_width_column_________________________________________________2017-03-27_/
nat16 Common_tabular_file_format::get_column_number(nat16 column_index)     const
{
   Column *col = dynamic_cast<Column *>(columns_1based.get_at(column_index));

   assert(false);
   // In need to check if column_index is truely index or number
   // if it is index then it probably needs to be get_at(column_index +1)


   return col ? col->number : 0;
}
//_get_start_column_________________________________________________2017-03-27_/
nat16 Common_tabular_file_format::get_position(nat16 column_index)     const
{
   Column *col = dynamic_cast<Column *>(columns_1based.get_at(column_index));
   return col ? col->position : 0;
}
//_get_start_column_________________________________________________2017-03-27_/
/*190325
nat16 Common_tabular_file_format::get_start_column(nat16 column_index)     const
{
   Column *col = dynamic_cast<Column *>(columns_1based.get_at(column_index));
   return col ? col->start_number : 0;
}
//_get_start_column_________________________________________________2017-03-27_/
*/



std::string *Common_tabular_file_format::render_blank
(nat16 column_index, nat32 row_index)                                 rendition_
{
   nat32 row_number = row_index + 1;
   std::string *blank = 0;
   if (row_number < column_headers_delineation.start_row_number)
   {  // we are in headers region
      return 0;  // NYI WARNING
      // should lookup if the position falls in metadata
   }
   else // we are in data region
   {
     Column *col = dynamic_cast<Column *>(columns_1based.get_at(column_index));
     if (col)
     {
      nat16 col_width = col->get_field_width();
      if (row_number < detail_lines_delineation.start_row_number)
      {  // We haven't reached detail lines yet, so we must be in column headers
         if (col_width)
         {
            blank = new std::string;
            compose_formatted_string_from_cstr
               ((*blank)
               ,""
               ,column_headers_delineation.text_quote_mode_clad.get()
               ,col_width);

         }
      } else // we are in data / detail lines
      {  // assume the column is data
         // moved Column *col = dynamic_cast<Column *>(columns_1based.get_at(column_index));
         if (col_width)
         {
            const char *preferred_value = "";
            if (col->static_text.length())
               preferred_value = col->static_text.c_str();
            if (col->missing_value.length())
               preferred_value = col->missing_value.c_str();
            blank = new std::string;
            compose_formatted_string_from_cstr
               ((*blank)
               ,preferred_value
               ,detail_lines_delineation.text_quote_mode_clad.get()
               ,col_width);

         }
      }
     }
     else
     {
         std::clog << "failed: column(index) = " << col << std::endl;
     }
   }
   return blank;
}
//_render_blank_____________________________________________________2019-01-08_/
bool Common_tabular_file_format::get_end()
{
   // The tabular file description does not needs to specify
   // column numbering or positioning the column starts in the file.
   // If omitted it is assumed these will be relative
   // But text file writers and worksheet output will
   // need these values, so we
   // setup columns number and position based on relative occurance
   // in the TDF file and/or available information
   nat32 col_position = 1;
   nat32 col_number   = 1;
   FOR_EACH_IN(column,Column,columns_1based,col_iter)
   {
      if (column->position)
         // if the format file did specify a position for a column
         // the subsequent columns that don't have specific column numbers
         // will be assumed to be relative to this specified column number.
         col_position = column->position;
      else (column->position = col_position);

      nat16 field_width = column->field_width;
      if (field_width == 0)
      {  field_width = 8;  //assuming numeric value default width 8
      }
      col_position += field_width;

      if (column->number == 0)
         column->number = col_number;
      col_number += (column->spread_over_columns > 1)
         ? column->spread_columns : 1;
   } FOR_EACH_END(col_iter)
   return Common_parameters_data_record::get_end();
}
//_get_end__________________________________________________________2019-03-25_/

} // namespace CORN

