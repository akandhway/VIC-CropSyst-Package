#include "corn/tabular/delineation.h"
#include "corn/math/compare.hpp"
#include <iostream>

namespace CORN {
//______________________________________________________________________________
const char *tabulation_label_table[] =
{"intrinsic"
,"fixed"
,"delimit"     // was renamed from character
,"character"   // obsolete rename this to delimit
,0 };
//______________________________________________________________________________
/*200220 now stored as string
const char *text_quote_mode_label_table[] =
{"unquoted"
,"single"
,"double"
,"alternating"
,0 };
//______________________________________________________________________________
*/
const char *relative_to_label_table[] =
{  "file"
,  "data"
,  "page"
,  "block"
,0};
//______________________________________________________________________________
#define LABEL_start_row        "start_row"
/*200220 obsolete
#define LABEL_text_quote_mode       "text_quote_mode"
#define LABEL_continuous_delimiter  "continuous_delimiter"
#define LABEL_delimiter_space       "delimiter_space"
#define LABEL_delimiter_comma       "delimiter_comma"
#define LABEL_delimiter_tab         "delimiter_tab"
#define LABEL_delimiter_semicolon   "delimiter_semicolon"
#define LABEL_delimiter_other       "delimiter_other"
#define LABEL_other_delimiter       "other_delimiter"
#define LABEL_decimal_mark          "decimal_mark"
*/

/*200220 reimplement using Map idiom
//______________________________________________________________________________
bool Extent__layout::setup_structure(CORN::Data_record &data_rec,bool ) modification_
{  data_rec.expect_enum("start_row_relative_to",relative_to_clad);               //060823
   //200220 data_rec.expect_int16(LABEL_start_row,start_row_number);
   data_rec.expect_int16("begin_offset",begin_offset);                           //200221
   data_rec.expect_string("begin_marker",begin_marker,100);                      //050321
   data_rec.expect_string("end_marker",end_marker,100);                          //050321
   return true;
}
//_setup_structure_____________________________________________________________/
bool Delineation::setup_structure(CORN::Data_record &data_rec,bool for_write) modification_
{  bool satup = Extent__layout::setup_structure(data_rec,for_write);
   data_rec.expect_enum("delimit_mode",tabulation_clad);                         //040925
   data_rec.expect_enum(LABEL_text_quote_mode,text_quote_mode_clad);             //02050
   if (!for_write ||
      (    (tabulation_clad.get() == delimit_TABULATION)                            //200131
       #if ((CS_VERSION > 0) && (CS_VERSION < 6))
        || (tabulation_clad.get() == DELIMIT_character_renamed)
       #endif
        ))             //040925
   {  data_rec.expect_bool(LABEL_continuous_delimiter,continuous_delimiter,VV_bool_entry::form_true);
      data_rec.expect_bool(LABEL_delimiter_space,delimiter_space,VV_bool_entry::form_true);
      data_rec.expect_bool(LABEL_delimiter_comma,delimiter_comma,VV_bool_entry::form_true);
      data_rec.expect_bool(LABEL_delimiter_tab,delimiter_tab,VV_bool_entry::form_true);
      data_rec.expect_bool(LABEL_delimiter_semicolon,delimiter_semicolon,VV_bool_entry::form_true);
      data_rec.expect_bool(LABEL_delimiter_other,delimiter_other,VV_bool_entry::form_true);
      data_rec.expect_int16(LABEL_other_delimiter,other_delimiter_16);
   }
   data_rec.expect_string(LABEL_decimal_mark,decimal_mark,10);                   //050402

   //180508 reimplement the decimal mark would be a property of the entire document.

   data_rec.expect_string("notes",notes,512);                                    //050517

   //180508 reimplement notes would be a property of the entire document.

   return satup;
}
//_setup_structure_____________________________________________________________/
*/
bool Delineation::is_delimiter(char potential_delimiter)            affirmation_
{
   return
      separation.delimiter.find(potential_delimiter) != std::string::npos;       //200220
/*200220
      (delimiter_space     && (potential_delimiter == ' '))
   || (delimiter_comma     && (potential_delimiter == ','))
   || (delimiter_tab       && (potential_delimiter == '\t'))
   || (delimiter_semicolon && (potential_delimiter == ';'))
   || (delimiter_other     && (potential_delimiter == other_delimiter_16));
*/
}
//_is_delimiter________________________________________________________________/
bool Delineation::has_delimiter()                                   affirmation_
{
   bool has = !separation.delimiter.empty();                                     //200220
   /*200220
   bool has =  delimiter_string
      ||       delimiter_other
      ||       delimiter_semicolon
      ||       delimiter_comma
      ||       delimiter_tab
      ||       delimiter_space;
   */
   return has;
}
//_has_delimiter____________________________________________________2019-01-07_/
const char *Delineation::append_delimiter(std::string &return_buffer)      const
{
   // When reading files, multiple potential delimiters could be optionally specified as delimiters
   // When writing files, only a single delimiter is available.

   return_buffer += separation.delimiter[0];                                     //200220
   /*200220
   if (delimiter_string)   return_buffer.append(other_delimiter_string);
   else if (delimiter_other)
   {  char buffer_cstr[3];
      buffer_cstr[0] = (char)other_delimiter_16; buffer_cstr[1] = 0;
      return_buffer.append(std::string (buffer_cstr));
   }
   else if (delimiter_semicolon)return_buffer.append(";");
   else if (delimiter_comma)    return_buffer.append(",");
   else if (delimiter_tab)      return_buffer.append("\t");
   else if (delimiter_space)    return_buffer.append(" ");
   */
   return return_buffer.c_str();
}
//_append_delimiter_________________________2020-02-20__2019-01-06__2005-08-30_/
bool Delineation::default_R_text()                                 modification_
{

   tabulation_clad.set(delimit_TABULATION);
   separation.continuous= false;
   separation.delimiter = "\t";
   separation.quotation = ""; //RLN warning, need to verify
   separation.decimal = '.';
   // . for US  , for other countries

/*200220 replaced with separation
   tabulation_clad.set(delimit_TABULATION); //200131 (DELIMIT_character);
   continuous_delimiter = false;
   delimiter_tab        = true;
   delimiter_space      = false;
   delimiter_comma      = false;
   delimiter_semicolon  = false;
   delimiter_other      = false;
   delimiter_string     = false;
   // NA other_delimiter_string;    // Other extended delimiter (I.e. HTML table <TH><TD>) //050830
   text_quote_mode_clad.set(NO_QUOTE); //RLN warning, need to verify
      // NO_QUOTE, SINGLE_QUOTE, DOUBLE_QUOTE, ALTERNATING_QUOTE
   decimal_mark = ".";  // . for US  , for other countries   This probably should be moved to Tabular file since it is a property of the file format, not delineation //050402
*/
   return true;
}
//_default_R_text_______________________________________2002-02-20__2014-10-08_/
bool Delineation::copy_from(const Delineation &from) modification_
{
   tabulation_clad.set(from.tabulation_clad.get());
   separation.continuous= from.separation.continuous;
   separation.delimiter = from.separation.delimiter;
   separation.quotation = from.separation.quotation;
   separation.decimal   = from.separation.decimal;
   //extent.notes         = from.extent.notes;
   // NYI should eventually copy all the extent, at this time I only needed the start row
   extent.begin_offset  = from.extent.begin_offset;
/*200220 reimplemented
   tabulation_clad.set(from.tabulation_clad.get());
   continuous_delimiter    = from.continuous_delimiter;
   delimiter_tab           = from.delimiter_tab;
   delimiter_space         = from.delimiter_space;
   delimiter_comma         = from.delimiter_comma;
   delimiter_semicolon     = from.delimiter_semicolon;
   delimiter_other         = from.delimiter_other;
   other_delimiter_16      = from.other_delimiter_16;
   delimiter_string        = from.delimiter_string;
   other_delimiter_string  = from.other_delimiter_string;
   text_quote_mode_clad.set(from.text_quote_mode_clad.get());                            //020505
   decimal_mark            = from.decimal_mark;
   notes                   = from.notes;
   // NYI should eventually copy all the extent, at this time I only needed the start row
   start_row_number       = from.start_row_number;

*/
   return true;
}
//_copy_from____________________________________________2002-02-20__2014-10-08_/
Delineation_tabular::Delineation_tabular()
: pagination                                                            ("none")
, lineation                                                           ("native")
, definer                                                                   ("") //990307
, inception                                                                   () //990307
, notes                                                                     ("")
/*200302 obsolete
, missing_data_marker                                                       ("") //090305
*/
, year_offset_for_dates_with_only_two_digits(0)                                //120331
, document                                                                    ()
, header                                                                      ()
, footer                                                                      ()
, detail                                                                      ()
{
}
//_Delineation_tabular:constructor__________________________________2020-03-06_/
bool
//200220 Common_tabular_file__format
Delineation_tabular
::default_R_text()                  modification_
{
   // Sets up format and delimit for R import/export text files.
   //start_row_number=1;
   document.extent.begin_offset = 0;                                             //200220
   header.extent.begin_offset = 0;                                               //200220
   detail.extent.begin_offset = 1;                                               //200220
   // no footer

   lineation = "native";                                                         //200220
   pagination = "none";                                                          //200220
   header.paginate = false;                                                      //200220
   //200220 format_file_type_clad.set(FILE_TYPE_text);
   /*200220
   carriage_return_line_feed  = false;
   paginated                  = false;
   FORTRAN_carriage_control   = false;
   delineation_header.paginate = false;                                          //200220
   */
   //200220 column_headers_every_page  = false;
   //200131 variable_order_clad.set(variable_order);
   //200220 missing_data_marker        = "";  // R can also be told to recognise  "NA" and "." and "na"
   document.missing           = "";
   bool col_delineation_set =
       header/*200220 column_headers_delineation*/.default_R_text()
    && detail/*200220 detail_lines_delineation*/  .default_R_text();

    /*200220 redone
   column_headers_delineation.start_row_number = 1;
   detail_lines_delineation.start_row_number = 2;
   */

   return col_delineation_set;
}
//_default_R_text___________________________________________________2014-10-08_/




const std::string &compose_formatted_string_from_cstr
(std::string &formatted_string
,const char *c_str
,std::string quotation                                                           //200220
//200220 ,CORN::Delineation::Text_quote_mode quote_mode                          //090712
,nat16 field_width  // will be 0 if not applicable
)                                                                                //190106
{
   int quote_count = 0;
   std::string quote_character(quotation);                                       //200220
      // using string because a quote may in the future be multiple characters (I.e. HTML)
   if (quotation.length() == 2) // special case for alternating indicator
#ifdef NYI
      {
         In this case scan the c_str, If it has a double quote in it then  append "'",
         if it has a single quote, then append
         quote_count = 2;
      }
#endif

/*200220
   std::string quote_character;
      // using string because a quote may in the future be multiple characters (I.e. HTML)
   switch (quote_mode)
   {  case CORN::Delineation::SINGLE_QUOTE : quote_character.append("\'"); quote_count = 2; break;
      case CORN::Delineation::DOUBLE_QUOTE : quote_character.append("\""); quote_count = 2; break;
      case CORN::Delineation::NO_QUOTE :  break;  // delimiter//091130
#ifdef NYI
      case CORN::Delineation::ALTERNATING_QUOTE :
      {
         In this case scan the c_str, If it has a double quote in it then  append "'",
         if it has a single quote, then append
         quote_count = 2;
      } break;
#endif
      // default is not quote
   }

*/
   formatted_string.append(quote_character);
   // if right justified or centered, first append padding
   formatted_string.append(c_str);
   if (field_width)
      {
         size_t formatted_string_length = formatted_string.length();             //130821
         int16 padding = field_width-formatted_string_length-quote_count;        //130821
         padding = CORN::must_be_0_or_greater<int16>(padding);                   //190106
         formatted_string.append(std::string(padding,' '));                      //190106
      }
   formatted_string.append(quote_character);
   return formatted_string;
}
//_compose_formatted_string_from_cstr___________________2019-01-06__2014-09-22_/
Table_definition::Column &Table_definition::provide_column
(nat16 column_index
//,CORN::Format_column &delineated_column
)                             provision_
{
   Table_definition::Column *col = 0;
   while ((col = dynamic_cast<Table_definition::Column *>
          (columns.get_at(column_index))) == 0)
   {  col = new Table_definition::Column
         //(delineated_column)
         ;
      columns.take(col);
   }
   return *col;
}
//_provide_column___________________________________________________2020-03-02_/
nat16 Table_definition::get_width_column(nat16 column_index)     const
{
   Column *col = dynamic_cast<Column *>
      (columns.get_at(column_index));
   return col ? col->delineation.width : 0;
}
//_get_width_column_________________________________________________2017-03-27_/
nat16 Table_definition::get_column_number(nat16 column_index)     const
{
   Column *col = dynamic_cast<Column *>(columns.get_at(column_index));

   assert(false);
   // In need to check if column_index is truely index or number
   // if it is index then it probably needs to be get_at(column_index +1)


   return col ? col->sheet.column /*number */ : 0;
}
//_get_start_column_________________________________________________2017-03-27_/
nat16 Table_definition::get_position(nat16 column_index)     const
{
   Column *col = dynamic_cast<Column *>(columns.get_at(column_index));
   return col ? col->delineation.position : 0;
}
//_get_start_column_________________________________________________2017-03-27_/
std::string *Table_definition::render_blank
(nat16 column_index, nat32 row_index)                                 rendition_
{
   nat32 row_number = row_index + 1;
   std::string *blank = 0;
   if (row_number < header.extent.begin_offset+1)
   {  // we are in headers region
      return 0;  // NYI WARNING
      // should lookup if the position falls in metadata
   }
   else // we are in data region
   {
     Column *col = dynamic_cast<Column *>(columns.get_at(column_index));
     if (col)
     {
      nat16 col_width = col->get_field_width();
      if (row_number < detail.extent.begin_offset+1)
      {  // We haven't reached detail lines yet, so we must be in column headers
         if (col_width)
         {
            blank = new std::string;
            compose_formatted_string_from_cstr
               ((*blank)
               ,""
               ,header.separation.quotation                                      //200220
               //200220 ,column_headers_delineation.text__quote_mode_clad.get()
               ,col_width);

         }
      } else // we are in data / detail lines
      {  // assume the column is data
         // moved Column *col = dynamic_cast<Column *>(columns.get_at(column_index));
         if (col_width)
         {
            const char *preferred_value = "";
            if (col->static_text.length())
               preferred_value = col->static_text.c_str();
            if (detail.missing.length())                                         //200302
               preferred_value = detail.missing.c_str();                         //200302
            /* 200302 moved to Delineation_column
            if (col->missing_value.length())
               preferred_value = col->missing_value.c_str();
            */
            blank = new std::string;
            compose_formatted_string_from_cstr
               ((*blank)
               ,preferred_value
               ,detail.separation.quotation                                      //200220
               //200220 ,detail_lines_delineation.text_quote_mode_clad.get()
               ,col_width);

         }
      }
     }
     else
     {
         std::clog << "failed: column(index) = " << col << std::endl;
     }
   }
   return blank;
}
//_render_blank_____________________________________________________2019-01-08_/
nat32 Table_definition::position_columns()
{
   // The tabular description does not need to specify
   // column numbering or positioning the column starts in the file.
   // If omitted it is assumed these will be relative
   // But text file writers and worksheet output will
   // need these values, so we
   // setup columns number and position based on relative occurance
   // in the TDF file and/or available information

   nat32 col_position = 1;
   nat32 col_number   = 1;
   FOR_EACH_IN(column,Column,columns,col_iter)
   {
      if (column->delineation.position)                                          //200302
         // if the format file did specify a position for a column
         // the subsequent columns that don't have specific column numbers
         // will be assumed to be relative to this specified column number.
         col_position = column->delineation.position;                            //200302
      else (column->delineation.position = col_position);                        //200302

      nat16 field_width = column->delineation.width;                             //200224
      if (field_width == 0)
      {  field_width = 8;  //assuming numeric value default width 8
      }
      col_position += field_width;

      if (column->sheet.column/*number*/ == 0)
         column->sheet.column/*number*/ = col_number;
      col_number += (column->spread > 1)
         ? column->spread : 1;
      /*200224
      col_number += (column->spread_over_columns > 1)
         ? column->spread_columns : 1;
      */

   } FOR_EACH_END(col_iter)
   return columns.count();
}
//_position_column__________________________________________________2020-03-06_/


}//_namespace_CORN_____________________________________________________________/

