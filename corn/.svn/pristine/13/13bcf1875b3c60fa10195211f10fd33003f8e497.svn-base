#include "corn/data_source/datarec.h"
#include "corn/tabular/delineation.h"

namespace CORN {
//______________________________________________________________________________
const char *delimit_mode_label_table[] =
{"intrinsic"
,"fixed"
,"character"
,0 };
//______________________________________________________________________________
const char *text_quote_mode_label_table[] =
{"unquoted"
,"single"
,"double"
,"alternating"
,0 };
//______________________________________________________________________________
const char *relative_to_label_table[] =
{  "file"
,  "data"
,  "page"
,  "block"
,0};
//______________________________________________________________________________
#define LABEL_start_row        "start_row"
#define LABEL_text_quote_mode       "text_quote_mode"
#define LABEL_continuous_delimiter  "continuous_delimiter"
#define LABEL_delimiter_space       "delimiter_space"
#define LABEL_delimiter_comma       "delimiter_comma"
#define LABEL_delimiter_tab         "delimiter_tab"
#define LABEL_delimiter_semicolon   "delimiter_semicolon"
#define LABEL_delimiter_other       "delimiter_other"
#define LABEL_other_delimiter       "other_delimiter"
#define LABEL_decimal_mark          "decimal_mark"
//______________________________________________________________________________
bool Extent_layout::setup_structure(CORN::Data_record &data_rec,bool /*for_write*/) modification_
{  data_rec.expect_enum("start_row_relative_to",relative_to_clad);               //060823
	data_rec.expect_int16(LABEL_start_row,start_row_number);
   data_rec.expect_string("begin_marker",begin_marker,100);                      //050321
   data_rec.expect_string("end_marker",end_marker,100);                          //050321
   return true;
}
//______________________________________________________________________________
bool Delineation_layout::setup_structure(CORN::Data_record &data_rec,bool for_write) modification_
{  bool satup = Extent_layout::setup_structure(data_rec,for_write);
   data_rec.expect_enum("delimit_mode",delimit_mode_clad);                       //040925
   data_rec.expect_enum(LABEL_text_quote_mode,text_quote_mode_clad);             //02050
   if (!for_write || delimit_mode_clad.get() == DELIMIT_character)               //040925
   {  data_rec.expect_bool(LABEL_continuous_delimiter,continuous_delimiter,VV_bool_entry::form_true);
      data_rec.expect_bool(LABEL_delimiter_space,delimiter_space,VV_bool_entry::form_true);
      data_rec.expect_bool(LABEL_delimiter_comma,delimiter_comma,VV_bool_entry::form_true);
      data_rec.expect_bool(LABEL_delimiter_tab,delimiter_tab,VV_bool_entry::form_true);
      data_rec.expect_bool(LABEL_delimiter_semicolon,delimiter_semicolon,VV_bool_entry::form_true);
      data_rec.expect_bool(LABEL_delimiter_other,delimiter_other,VV_bool_entry::form_true);
      data_rec.expect_int16(LABEL_other_delimiter,other_delimiter_16);
   }
   data_rec.expect_string(LABEL_decimal_mark,decimal_mark,10);                   //050402

   //180508 reimplement the decimal mark would be a property of the entire document.

   data_rec.expect_string("notes",notes,512);                                    //050517

   //180508 reimplement notes would be a property of the entire document.

   return satup;
}
//______________________________________________________________________________
bool Delineation_layout::is_delimiter(char potential_delimiter)     affirmation_
{  return
      (delimiter_space     && (potential_delimiter == ' '))
   || (delimiter_comma     && (potential_delimiter == ','))
   || (delimiter_tab       && (potential_delimiter == '\t'))
   || (delimiter_semicolon && (potential_delimiter == ';'))
   || (delimiter_other     && (potential_delimiter == other_delimiter_16));
}
//______________________________________________________________________________
/*190106
const char *Delineation_layout::get_delimitor()                            const
{
//             When reading files, multiple potential delimitors could be optionally specified as delimitors
//             When writing files, only a single delimitor is available.
   return_buffer.assign("");
   if (delimiter_string)   return_buffer.assign(other_delimiter_string);
   else if (delimiter_other)
   {  char buffer_cstr[3];
      buffer_cstr[0] = (char)other_delimiter_16; buffer_cstr[1] = 0;
      return_buffer.assign(std::string (buffer_cstr));
   }
   else if (delimiter_semicolon)return_buffer.assign(";");
   else if (delimiter_comma)    return_buffer.assign(",");
   else if (delimiter_tab)      return_buffer.assign("\t");
   else if (delimiter_space)    return_buffer.assign(" ");
   return return_buffer.c_str();
}
//_2005-08-30___________________________________________________________________
*/
bool Delineation_layout::has_delimiter()                            affirmation_
{  bool has =  delimiter_string
      ||       delimiter_other
      ||       delimiter_semicolon
      ||       delimiter_comma
      ||       delimiter_tab
      ||       delimiter_space;
   return has;
}
//_has_delimiter____________________________________________________2019-01-07_/
const char *Delineation_layout::append_delimiter(std::string &return_buffer) const
{
   // When reading files, multiple potential delimitors could be optionally specified as delimitors
   // When writing files, only a single delimitor is available.

   if (delimiter_string)   return_buffer.append(other_delimiter_string);
   else if (delimiter_other)
   {  char buffer_cstr[3];
      buffer_cstr[0] = (char)other_delimiter_16; buffer_cstr[1] = 0;
      return_buffer.append(std::string (buffer_cstr));
   }
   else if (delimiter_semicolon)return_buffer.append(";");
   else if (delimiter_comma)    return_buffer.append(",");
   else if (delimiter_tab)      return_buffer.append("\t");
   else if (delimiter_space)    return_buffer.append(" ");
   return return_buffer.c_str();
}
//_append_delimitor_____________________________________2019-01-06__2005-08-30_/

bool Delineation_layout::default_R_text()                          modification_
{
   delimit_mode_clad.set(DELIMIT_character);
   continuous_delimiter = false;
   delimiter_tab        = true;
   delimiter_space      = false;
   delimiter_comma      = false;
   delimiter_semicolon  = false;
   delimiter_other      = false;
   delimiter_string     = false;
   // NA other_delimiter_string;    // Other extended delimiter (I.e. HTML table <TH><TD>) //050830
   text_quote_mode_clad.set(NO_QUOTE); //RLN warning, need to verify
      // NO_QUOTE, SINGLE_QUOTE, DOUBLE_QUOTE, ALTERNATING_QUOTE
   decimal_mark = ".";  // . for US  , for other countries   This probably should be moved to Tabular file since it is a property of the file format, not delineation //050402
   return true;
}
//_2014-10-08___________________________________________________________________
bool Delineation_layout::copy_from(const Delineation_layout &from) modification_
{
   delimit_mode_clad.set(from.delimit_mode_clad.get());
   continuous_delimiter    = from.continuous_delimiter;
   delimiter_tab           = from.delimiter_tab;
   delimiter_space         = from.delimiter_space;
   delimiter_comma         = from.delimiter_comma;
   delimiter_semicolon     = from.delimiter_semicolon;
   delimiter_other         = from.delimiter_other;
   other_delimiter_16      = from.other_delimiter_16;
   delimiter_string        = from.delimiter_string;
   other_delimiter_string  = from.other_delimiter_string;
   text_quote_mode_clad.set(from.text_quote_mode_clad.get());                            //020505
   decimal_mark            = from.decimal_mark;
   notes                   = from.notes;
   // NYI should eventually copy all the extent, at this time I only needed the start row
   start_row_number       = from.start_row_number;
   return true;
};
//_2014-10-08___________________________________________________________________
const std::string &compose_formatted_string_from_cstr
(std::string &formatted_string
,const char *c_str
,CORN::Delineation_layout::Text_quote_mode quote_mode                            //090712
,nat16 field_width  // will be 0 if not applicable
//,Delineation_layout::Delimit_mode delimit_mode
)                                                               //190106
{
   // This was originally in Tabular_text_file but has more general use.
   int quote_count = 0;
   std::string quote_character; // using string because a quote may in the future be multiple characters (I.e. HTML)
   switch (quote_mode)
   {  case CORN::Delineation_layout::SINGLE_QUOTE : quote_character.append("\'"); quote_count = 2; break;
      case CORN::Delineation_layout::DOUBLE_QUOTE : quote_character.append("\""); quote_count = 2; break;
      case CORN::Delineation_layout::ALTERNATING_QUOTE :  // May need to do something for ALTERNATION_QUOTE  091130
      case CORN::Delineation_layout::NO_QUOTE :  /* Do nothing in this case */ break;  //091130
#ifdef NYI
      case CORN::Delineation_layout::ALTERNATING_QUOTE :
      {
         In this case scan the c_str, If it has a double quote in it then  append "'",
         if it has a single quote, then append
         quote_count = 2;
      } break;
#endif
      // default is not quote
   }
   formatted_string.append(quote_character);
   // if right justified or centered, first append padding
   formatted_string.append(c_str);
   if (field_width)
      /*190106
      if (delimit_mode //190106 format.detail_lines_delineation.delimit_mode_labeled.get()
            == CORN::Delineation_layout::DELIMIT_fixed_width)
      */
      {
         //190106 int field_width = format.get_width_column(current_field_column);
         size_t formatted_string_length = formatted_string.length();             //130821
         int16 padding = field_width-formatted_string_length-quote_count;        //130821
         padding = CORN::must_be_0_or_greater<int16>(padding);                   //190106
         formatted_string.append(std::string(padding,' '));                      //190106
         /*190106
         for (size_t i = 1; i <= padding; i++)                                   //130821
            formatted_string.append(" ");
         */
      }
   formatted_string.append(quote_character);
   return formatted_string;
}
//_compose_formatted_string_from_cstr___________________2019-01-06__2014-09-22_/


//_
} // namespace CORN

