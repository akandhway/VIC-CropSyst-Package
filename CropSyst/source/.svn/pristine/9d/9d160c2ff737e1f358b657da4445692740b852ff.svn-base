#error check obsolete

#include "soilbase.h"
#include <math.h>


// This function returns the aoccomodated flow (in) (this can be negative)
float32 soil_base::determine_flow_to_move
(uint8   sublayer
,float32 entering_flow
,float32 reservoir
,float32 storage_content_limit)
{
  float32 non_accom_flow = 0.0 ; // m
  float32 unstored_flow = 0.0; // m
  float32 flow_and_reservoir = entering_flow + reservoir; // m
  float32 accomodatable_content = storage_content_limit - water_content[sublayer];
  float32 accomodatable_flow = accomodatable_content * thickness[sublayer]; // m
  if (accomodatable_flow > 0.0)
  {   non_accom_flow =
      (flow_and_reservoir > accomodatable_flow)
      ? flow_and_reservoir - accomodatable_flow
      :  0.0;
  }
  else // The water content is above the max storage at water pot -10 J/kg
  {
      unstored_flow = -accomodatable_flow;
      non_accom_flow = flow_and_reservoir ; // thus down flow will increase for next layer
  }
  return non_accom_flow + unstored_flow;
}
//_determine_flow_to_move___________________________________________1999-02-14_/
float32 soil_base::determine_flow_out
(uint8 sublayer
,float32  total_flow_to_move
,float32 &reservoir)
{
   float32 out_flow = 0.0;   // m
   float32 out_flow_max_sublayer // m
   = 86.4 * gravitation_const * get_sat_hydraul_cond_kg_s_m3(sublayer);

   if (total_flow_to_move < out_flow_max_sublayer)// We can move the remaining flow out
   {
      out_flow    = total_flow_to_move;
      reservoir   = 0.0;    //back flow or flow up
   }
   else
   {
      out_flow    = out_flow_max_sublayer;
      reservoir   = total_flow_to_move - out_flow_max_sublayer;
   }
   return out_flow;
}
//_determine_flow_out_______________________________________________1999-02-14_/
float32 soil_base::determine_flux  // kg/(m2 sec)
(uint8      sublayer
,float32    water_pot_adj_sublayer)
{
   return (((water_pot_adj_sublayer - water_pot[sublayer])
                     / thickness[sublayer]) -  gravitation_const)
                     * get_hydraulic_conductivity(sublayer);
};
//__________________________________________________________________1999-02-14_/
void soil_base::no_water_entering_soil_case()
{
   // only move water already in the soil
   soil_sublayer_array32(local_water_flux);
   local_water_flux[0]  = 0;
   for (uint8 sublayer = 1; sublayer <= get_num_sublayers_eff(); sublayer++)
   {
      //  This should be OK water potentials for num_sublayers_eff+1
      //  is set up in previous mass balance iteration.
      //  by convetion flow down is negative (different from above)


      local_water_flux[sublayer] = determine_flux(sublayer,water_pot[sublayer+1]);  //990106

      if (sublayer < get_num_sublayers_eff()) // last layer has no limit.
         if (local_water_flux[sublayer] < 0.0)
         {
            float32 movable_content = must_be_0_or_greater
               ((water_content[sublayer] - get_field_capacity_volumetric(sublayer)));

            float32 max_flux_out = CORN_min
                (- (movable_content / 86.4 *  get_thickness(sublayer))
                 + local_water_flux[sublayer-1]
                ,+ ((get_saturation_water_content(sublayer+1) - get_water_content(sublayer+1) )
                    / 86.4 *  get_thickness(sublayer+1)));
            if (is_zero(max_flux_out,/*200127 0.0,*/0.00000000001))
                 max_flux_out = 0.0;

            // Take the value closest to zero ( both should be neg or 0.0).
            local_water_flux[sublayer] = CORN_max(local_water_flux[sublayer],max_flux_out);

         }
         else
         {
            float32 movable_content = must_be_0_or_greater(
               (water_content[sublayer+1] - get_field_capacity_volumetric(sublayer+1)));
            float32 max_flux_in = CORN_min
                ( + ((get_saturation_water_content(sublayer) - water_content[sublayer] )
                     / 86.4 *  get_thickness(sublayer))
                  + local_water_flux[sublayer-1]
                , + (movable_content / 86.4 *  get_thickness(sublayer+1)));

            if (is_zero(max_flux_in ,/*200127 0.0,*/0.00000000001))
                  max_flux_in = 0.0;
            // Take the value closest to zero ( both should be pos. or 0.0).
              local_water_flux[sublayer] = min(local_water_flux[sublayer],max_flux_in);
         }
  }

  for (uint8 sublayer = 1; sublayer <= get_num_sublayers_eff() ; sublayer++)
  { // Do it for real now:
      float32 change_in_water_content = (-local_water_flux[sublayer-1] +
            local_water_flux[sublayer]) * 86.4 / thickness[sublayer];
      water_content[sublayer] += change_in_water_content;                        //990106
      water_flux[sublayer] = local_water_flux[sublayer];
   }
}
//__________________________________________________________________1999-02-14_/
float32 soil_base::infiltration_darcian_cascade
( float32 management_irrigation                                                  //990216
, float32 &additional_runoff // m any additional computed runoff
)
{
   soil_sublayer_array32(old_water_content);                                     //990212
   copy_sublayer_array(old_water_content,water_content);                         //990214
   if (water_entering_soil > 0.0)
   {
      float32 previous_layer_down_flow = water_entering_soil;
      float32 down_flow = water_entering_soil;  // m3 water/m2 soil (m)
      for (uint8 sublayer = 1 ; sublayer <= get_num_sublayers_eff(); sublayer++)
      {  // some optimized variables
         float32 saturation_water_content_sl = get_saturation_water_content(sublayer); //990214
         float32 thickness_sl = get_thickness(sublayer);                         //990214
         float32 air_entry_pot_sl = get_air_entry_pot(sublayer);
         float32 b_sl   =  get_soil_b(sublayer);
         // Determine the flow what will fill to water pot -10 J/kg.
         float32 storage_content_at10J_kg = //  at water pot -10 J/kg
            saturation_water_content_sl
              * pow((-10.0 /air_entry_pot_sl ) ,-1.0/ b_sl);
         float32 flow_to_move = // m
            determine_flow_to_move(sublayer,down_flow,0.0,storage_content_at10J_kg);
         float32 flow_out = // m
            determine_flow_out(sublayer,flow_to_move,reservoir[sublayer]);
         water_flux[sublayer] =  -flow_out / 86.4;  // {kg /(m2 sec) (neg. for downflow)} //990106
         if (reservoir[sublayer] > 0.0)
         {
            float32 req_water_content_to_saturate = (saturation_water_content_sl - storage_content_at10J_kg);
            float32 reservoir_content = reservoir[sublayer] / thickness_sl; // m3/m3
            if (req_water_content_to_saturate > reservoir_content)
               water_content[sublayer] = storage_content_at10J_kg + reservoir_content;
            else
            {  water_content[sublayer] = saturation_water_content_sl;
               reservoir[sublayer] -= (req_water_content_to_saturate * thickness_sl);
            }
         }
         else
            water_content[sublayer] +=
               ((previous_layer_down_flow - flow_out) / thickness_sl);           //990106
         // This may exceed saturation
         // setup for next layer:
         down_flow = flow_out;                                                   //990106
         previous_layer_down_flow = flow_out;                                    //990106
      }
      if (get_water_table_encountered())
      { // If water table then drainage is added to back flow of num_sublayers_eff
         reservoir[get_num_sublayers_eff()] += down_flow;                        //990106
         balance_drainage = 0.0;
      }

      float32 up_flux = determine_flux(get_num_sublayers_eff(),water_pot[get_num_sublayers_eff()+1]);
      float32 up_flow = (up_flux > 0)   // {m3 water/m2 soil (m) }
      ? up_flux * 86.4
      : 0.0;

      float32 previous_layer_up_flow = up_flow;                                  //990106
      for (uint8 sublayer = get_num_sublayers_eff(); sublayer >= 1; sublayer--)
      {
         float32 flow_out = determine_flow_to_move
         (sublayer,up_flow,reservoir[sublayer], get_saturation_water_content(sublayer));
         water_flux[sublayer] += previous_layer_up_flow / 86.4;  // kg/(m2 sec)  //990106

         water_content[sublayer] +=                                              //990106
         ((up_flow + reservoir[sublayer] - flow_out) / thickness[sublayer]);
         up_flow = flow_out;                                                     //990106
         previous_layer_up_flow = up_flow;                                       //990106
      }
      additional_runoff = up_flow; // m

   }
   #ifdef TEMP_DISABLED
   // Causing problems with next day
   else
      no_water_entering_soil_case();
   #endif
   for (nat8 sublayer = 1 ; sublayer <= get_num_sublayers_eff(); sublayer++)
   {
      water_pot[sublayer] = waterpotential(sublayer);                            //990214
      water_pot[sublayer+1] = water_pot[sublayer];                               //980604
   }

   // WARNING this needs to be for time step, because
   // this is being called within finite diff time step control!!!!
   // Ie. increment drainage and change secs per day to time_step
      balance_drainage = - seconds_per_day*(mm_to_m(water_flux[get_num_sublayers_eff()])); //{time_step};
      uint8 leaching_sublayer = sublayer_at(get_leaching_depth(),false);         //990214
      reported_drainage =  override_leaching_depth
      ? - seconds_per_day*(mm_to_m(water_flux[leaching_sublayer])) //{time_step} //990214
      : balance_drainage;

      chemical_transport_and_exchange                                            //980724
      (get_num_sublayers_eff()
      ,old_water_content
      ,water_content // new_water_content
      ,water_entering_soil + management_irrigation  // Warning check should be: total water entering (irrig + precip)
      ,water_entering_soil
      ,override_leaching_depth                                                   //990213
      ,leaching_sublayer                                                         //990213
      );
   return water_entering_soil - additional_runoff; // <- Check this with Claudio //990214
}
//_infiltration_darcian_cascade_____________________________________1999-12-14_/

